<style>
  #bg-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    opacity: 0.4;
    pointer-events: none;
    transition: transform 0.3s ease;
  }
  
  #bg-canvas.right-positioned {
    transform: translateX(35%);
  }
</style>

<canvas id="bg-canvas"></canvas>

<script>
  const canvas = document.getElementById('bg-canvas');
  if (!canvas) throw new Error('Canvas not found');
  
  const ctx = canvas.getContext('2d');

  let width, height;
  let animationId;
  let currentTheme = 'cellular-automata'; // 'cellular-automata', 'turbulence', or 'differential-equation'
  
  // Color customization
  let customColor = { light: 'rgba(45,45,45,0.8)', dark: 'rgba(201,169,97,0.8)' };

  // Cellular Automata State
  let grid;
  let cols, rows;
  const resolution = 20;

  // Turbulence State
  let particles = [];
  const particleCount = 500;
  let mouseX = width / 2;
  let mouseY = height / 2;
  let mouseInfluence = 0;
  
  // Differential Equation State
  let deParticles = [];
  const deParticleCount = 300;
  let time = 0;
  let selectedEquationTemplate = null; // Current equation template (lorenz, vanderpol, pendulum)

  function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    initTheme();
  }

  function initTheme() {
    // Clear canvas on theme init to prevent ghosting
    if (ctx) ctx.clearRect(0, 0, width, height);

    if (currentTheme === 'cellular-automata') {
      initCA();
    } else if (currentTheme === 'turbulence') {
      initTurbulence();
    } else {
      initDifferentialEquation();
    }
  }

  // --- Cellular Automata (Game of Life) ---
  function initCA() {
    cols = Math.ceil(width / resolution);
    rows = Math.ceil(height / resolution);
    grid = new Array(cols).fill(null).map(() => new Array(rows).fill(null).map(() => Math.random() > 0.85 ? 1 : 0));
  }

  function drawCA() {
    const isDark = document.documentElement.classList.contains('dark');
    ctx.fillStyle = isDark ? customColor.dark : customColor.light;
    ctx.clearRect(0, 0, width, height);
    
    let next = grid.map(arr => [...arr]);

    for (let i = 0; i < cols; i++) {
      for (let j = 0; j < rows; j++) {
        let state = grid[i][j];
        if (state === 1) {
          ctx.fillRect(i * resolution, j * resolution, resolution - 1, resolution - 1);
        }

        // Count neighbors
        let sum = 0;
        let neighbors = countNeighbors(grid, i, j);

        if (state === 0 && neighbors === 3) {
          next[i][j] = 1;
        } else if (state === 1 && (neighbors < 2 || neighbors > 3)) {
          next[i][j] = 0;
        } else {
          next[i][j] = state;
        }
      }
    }
    grid = next;
  }

  function countNeighbors(grid, x, y) {
    let sum = 0;
    for (let i = -1; i < 2; i++) {
      for (let j = -1; j < 2; j++) {
        let col = (x + i + cols) % cols;
        let row = (y + j + rows) % rows;
        sum += grid[col][row];
      }
    }
    sum -= grid[x][y];
    return sum;
  }

  // --- Turbulence (Simple Flow Field) ---
  function initTurbulence() {
    particles = [];
    for(let i=0; i<particleCount; i++) {
      particles.push({
        x: Math.random() * width,
        y: Math.random() * height,
        vx: 0,
        vy: 0,
        size: Math.random() * 3 + 0.5, // Varied sizes
        opacity: Math.random() * 0.5 + 0.5 // Varied opacity
      });
    }
  }

  function drawTurbulence() {
    const isDark = document.documentElement.classList.contains('dark');
    // Use semi-transparent fill for trail effect
    ctx.fillStyle = isDark ? 'rgba(26,26,26,0.05)' : 'rgba(254,254,254,0.05)';
    ctx.fillRect(0, 0, width, height);
    
    // Simple noise-like flow
    const time = Date.now() * 0.0003;
    
    for(let p of particles) {
      // More complex flow field
      const angle = (
        Math.sin(p.x * 0.003 + time) + 
        Math.cos(p.y * 0.003 + time) +
        Math.sin((p.x + p.y) * 0.002 + time * 0.5)
      ) * Math.PI;
      
      // Mouse attraction force
      const dx = mouseX - p.x;
      const dy = mouseY - p.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const mouseForce = mouseInfluence > 0 ? Math.min(200 / (dist + 1), 5) : 0;
      
      p.vx += Math.cos(angle) * 0.15 + (dx / dist) * mouseForce * 0.1;
      p.vy += Math.sin(angle) * 0.15 + (dy / dist) * mouseForce * 0.1;
      
      // Friction
      p.vx *= 0.96;
      p.vy *= 0.96;
      
      p.x += p.vx;
      p.y += p.vy;
      
      // Wrap around
      if(p.x < 0) p.x = width;
      if(p.x > width) p.x = 0;
      if(p.y < 0) p.y = height;
      if(p.y > height) p.y = 0;
      
      // Draw particle with glow effect
      const isDark = document.documentElement.classList.contains('dark');
      ctx.fillStyle = isDark ? customColor.dark.replace('0.8', p.opacity) : customColor.light.replace('0.8', p.opacity);
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  // --- Differential Equation (Customizable) ---
  let customFunctions = null;

  function initDifferentialEquation() {
    // Clear canvas immediately to remove "ghosts" of previous state
    if (ctx) ctx.clearRect(0, 0, width, height);
    
    deParticles = [];
    time = 0;
    
    // Default to Lorenz if no template selected or invalid
    if (!selectedEquationTemplate || (selectedEquationTemplate !== 'lorenz' && selectedEquationTemplate !== 'custom')) {
      selectedEquationTemplate = 'lorenz';
    }

    // Initialize particles (same for both modes for now, can be customized later)
    for(let i=0; i<deParticleCount; i++) {
      deParticles.push({
        x: (Math.random() - 0.5) * 20,
        y: (Math.random() - 0.5) * 20,
        z: Math.random() * 40,
        size: Math.random() * 2 + 1,
        opacity: Math.random() * 0.6 + 0.4,
      });
    }

    if (selectedEquationTemplate === 'custom') {
      try {
        const savedCustom = JSON.parse(localStorage.getItem('customEquationData'));
        if (savedCustom) {
          // Create functions from strings
          // Variables: x, y, z, t, sigma, rho, beta
          // We allow standard Math functions
          const createFunc = (str) => {
            // Replace common math functions to be accessible directly if needed, 
            // or just rely on Math.sin etc. 
            // For better UX, we might want to allow 'sin(x)' instead of 'Math.sin(x)'
            // But for safety and simplicity in this iteration, let's assume standard JS math or pre-process.
            // Let's do a simple pre-process to allow sin, cos, etc.
            let body = 'return ' + str
              .replace(/\bsin\b/g, 'Math.sin')
              .replace(/\bcos\b/g, 'Math.cos')
              .replace(/\btan\b/g, 'Math.tan')
              .replace(/\babs\b/g, 'Math.abs')
              .replace(/\bsqrt\b/g, 'Math.sqrt')
              .replace(/\bpow\b/g, 'Math.pow')
              .replace(/\bPI\b/g, 'Math.PI');
              
            return new Function('x', 'y', 'z', 't', body);
          };

          customFunctions = {
            dx: createFunc(savedCustom.dx),
            dy: createFunc(savedCustom.dy),
            dz: createFunc(savedCustom.dz)
          };
        } else {
          // Fallback to Lorenz if custom data missing
          selectedEquationTemplate = 'lorenz';
        }
      } catch (e) {
        console.error('Error parsing custom equation:', e);
        selectedEquationTemplate = 'lorenz';
      }
    }
  }
  
  function drawDifferentialEquation() {
    const isDark = document.documentElement.classList.contains('dark');
    ctx.fillStyle = isDark ? 'rgba(26,26,26,0.03)' : 'rgba(254,254,254,0.03)';
    ctx.fillRect(0, 0, width, height);
    
    const dt = 0.005;
    
    if (selectedEquationTemplate === 'lorenz') {
      // Lorenz Attractor
      const sigma = 10;
      const rho = 28;
      const beta = 8/3;
      
      for(let p of deParticles) {
        const dx = sigma * (p.y - p.x) * dt;
        const dy = (p.x * (rho - p.z) - p.y) * dt;
        const dz = (p.x * p.y - beta * p.z) * dt;
        
        p.x += dx;
        p.y += dy;
        p.z += dz;
        
        const scale = 8;
        const screenX = width / 2 + p.x * scale;
        const screenY = height / 2 + p.y * scale;
        
        ctx.fillStyle = isDark ? customColor.dark.replace('0.8', p.opacity) : customColor.light.replace('0.8', p.opacity);
        ctx.beginPath();
        ctx.arc(screenX, screenY, p.size, 0, Math.PI * 2);
        ctx.fill();
        
        if (Math.abs(p.x) > 30 || Math.abs(p.y) > 30 || p.z > 60 || p.z < 0) {
          p.x = (Math.random() - 0.5) * 20;
          p.y = (Math.random() - 0.5) * 20;
          p.z = Math.random() * 40;
        }
      }
    } else if (selectedEquationTemplate === 'custom' && customFunctions) {
      // Custom Equation
      for(let p of deParticles) {
        try {
          const dx = customFunctions.dx(p.x, p.y, p.z, time) * dt;
          const dy = customFunctions.dy(p.x, p.y, p.z, time) * dt;
          const dz = customFunctions.dz(p.x, p.y, p.z, time) * dt;
          
          p.x += dx;
          p.y += dy;
          p.z += dz;
          
          // Auto-scaling might be tricky for custom equations, sticking to Lorenz-ish scale for now
          // or maybe slightly smaller scale to be safe
          const scale = 8; 
          const screenX = width / 2 + p.x * scale;
          const screenY = height / 2 + p.y * scale;
          
          ctx.fillStyle = isDark ? customColor.dark.replace('0.8', p.opacity) : customColor.light.replace('0.8', p.opacity);
          ctx.beginPath();
          ctx.arc(screenX, screenY, p.size, 0, Math.PI * 2);
          ctx.fill();
          
          // Generic bounds check - if it explodes, reset
          if (Math.abs(p.x) > 50 || Math.abs(p.y) > 50 || Math.abs(p.z) > 100 || isNaN(p.x)) {
             p.x = (Math.random() - 0.5) * 20;
             p.y = (Math.random() - 0.5) * 20;
             p.z = Math.random() * 40;
          }
        } catch (e) {
          // If equation fails at runtime, stop drawing to prevent console spam
          selectedEquationTemplate = 'lorenz'; 
          initDifferentialEquation();
          break;
        }
      }
    }
    
    time += dt;
  }

  function animate() {
    if (currentTheme === 'cellular-automata') {
      if (Date.now() % 100 < 20) drawCA(); 
    } else if (currentTheme === 'turbulence') {
      drawTurbulence();
    } else {
      drawDifferentialEquation();
    }
    animationId = requestAnimationFrame(animate);
  }

  window.addEventListener('resize', resize);
  resize();
  animate();
  
  // Mouse tracking for turbulence
  window.addEventListener('mousemove', (e) => {
    mouseX = e.clientX;
    mouseY = e.clientY;
    mouseInfluence = 1;
  });
  
  // Decay mouse influence over time
  setInterval(() => {
    mouseInfluence *= 0.95;
  }, 50);

  // Listen for theme change event
  window.addEventListener('theme-change', (e) => {
    currentTheme = e.detail.theme;
    initTheme();
  });
  
  // Listen for color change event
  window.addEventListener('color-change', (e) => {
    customColor = e.detail;
  });
  
  // Listen for equation selection event
  window.addEventListener('equation-selected', (e) => {
    const detail = e.detail;
    
    if (detail.type === 'custom') {
      selectedEquationTemplate = 'custom';
      localStorage.setItem('selectedEquation', 'custom');
      localStorage.setItem('customEquationData', JSON.stringify(detail.data));
    } else {
      selectedEquationTemplate = 'lorenz';
      localStorage.setItem('selectedEquation', 'lorenz');
    }
    
    // Re-initialize the differential equation with new template
    if (currentTheme === 'differential-equation') {
      initDifferentialEquation();
    }
  });
  
  // Load saved equation template on page load
  const savedEquation = localStorage.getItem('selectedEquation');
  if (savedEquation) {
    selectedEquationTemplate = savedEquation;
  }
  
  // Apply positioning based on current page
  function updateCanvasPosition() {
    const isHomepage = window.location.pathname === '/' || window.location.pathname === '/index.html';
    
    if (!isHomepage && currentTheme === 'differential-equation') {
      canvas.classList.add('right-positioned');
    } else {
      canvas.classList.remove('right-positioned');
    }
  }
  
  // Update position on load and when theme changes
  updateCanvasPosition();
  window.addEventListener('theme-change', updateCanvasPosition);
  
  // Also listen for page navigation (for SPAs)
  if (document.addEventListener) {
    document.addEventListener('astro:page-load', updateCanvasPosition);
  }

</script>
