  #bg-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    opacity: 0.4; /* Increased opacity for visibility */
    pointer-events: none;
  }
</style>

<canvas id="bg-canvas"></canvas>

<script>
  const canvas = document.getElementById('bg-canvas');
  if (!canvas) throw new Error('Canvas not found');
  
  const ctx = canvas.getContext('2d');

  let width, height;
  let animationId;
  let currentTheme = 'cellular-automata'; // 'cellular-automata' or 'turbulence'

  // Cellular Automata State
  let grid;
  let cols, rows;
  const resolution = 20;

  // Turbulence State
  let particles = [];
  const particleCount = 100;

  function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    initTheme();
  }

  function initTheme() {
    if (currentTheme === 'cellular-automata') {
      initCA();
    } else {
      initTurbulence();
    }
  }

  // --- Cellular Automata (Game of Life) ---
  function initCA() {
    cols = Math.ceil(width / resolution);
    rows = Math.ceil(height / resolution);
    grid = new Array(cols).fill(null).map(() => new Array(rows).fill(null).map(() => Math.random() > 0.85 ? 1 : 0));
  }

  function drawCA() {
    // Use more visible colors
    ctx.fillStyle = document.documentElement.classList.contains('dark') ? 'rgba(255,255,255,0.15)' : 'rgba(0,0,0,0.1)';
    ctx.clearRect(0, 0, width, height);
    
    let next = grid.map(arr => [...arr]);

    for (let i = 0; i < cols; i++) {
      for (let j = 0; j < rows; j++) {
        let state = grid[i][j];
        if (state === 1) {
          ctx.fillRect(i * resolution, j * resolution, resolution - 1, resolution - 1);
        }

        // Count neighbors
        let sum = 0;
        let neighbors = countNeighbors(grid, i, j);

        if (state === 0 && neighbors === 3) {
          next[i][j] = 1;
        } else if (state === 1 && (neighbors < 2 || neighbors > 3)) {
          next[i][j] = 0;
        } else {
          next[i][j] = state;
        }
      }
    }
    grid = next;
  }

  function countNeighbors(grid, x, y) {
    let sum = 0;
    for (let i = -1; i < 2; i++) {
      for (let j = -1; j < 2; j++) {
        let col = (x + i + cols) % cols;
        let row = (y + j + rows) % rows;
        sum += grid[col][row];
      }
    }
    sum -= grid[x][y];
    return sum;
  }

  // --- Turbulence (Simple Flow Field) ---
  function initTurbulence() {
    particles = [];
    for(let i=0; i<particleCount; i++) {
      particles.push({
        x: Math.random() * width,
        y: Math.random() * height,
        vx: 0,
        vy: 0,
        size: Math.random() * 2 + 1
      });
    }
  }

  function drawTurbulence() {
    ctx.fillStyle = document.documentElement.classList.contains('dark') ? 'rgba(255,255,255,0.15)' : 'rgba(0,0,0,0.15)';
    ctx.clearRect(0, 0, width, height); // Clear with transparency for trail effect? No, clean clear for now.
    
    // Simple noise-like flow
    const time = Date.now() * 0.0005;
    
    ctx.beginPath();
    for(let p of particles) {
      // Simple flow field logic (mocking Perlin noise with sine waves)
      const angle = (Math.cos(p.x * 0.005 + time) + Math.sin(p.y * 0.005 + time)) * Math.PI;
      
      p.vx += Math.cos(angle) * 0.1;
      p.vy += Math.sin(angle) * 0.1;
      
      // Friction
      p.vx *= 0.95;
      p.vy *= 0.95;
      
      p.x += p.vx;
      p.y += p.vy;
      
      // Wrap around
      if(p.x < 0) p.x = width;
      if(p.x > width) p.x = 0;
      if(p.y < 0) p.y = height;
      if(p.y > height) p.y = 0;
      
      ctx.moveTo(p.x, p.y);
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    }
    ctx.fill();
  }

  function animate() {
    if (currentTheme === 'cellular-automata') {
      // Slow down CA
      if (Date.now() % 100 < 20) drawCA(); 
    } else {
      drawTurbulence();
    }
    animationId = requestAnimationFrame(animate);
  }

  window.addEventListener('resize', resize);
  resize();
  animate();

  // Listen for theme change event
  window.addEventListener('theme-change', (e) => {
    currentTheme = e.detail.theme;
    initTheme();
  });
</script>
