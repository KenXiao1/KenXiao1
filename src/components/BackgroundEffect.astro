<style>
  #bg-canvas, #bg-canvas-3d {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    opacity: 0.4;
    pointer-events: none;
    transition: opacity 0.5s ease;
  }
  
  #bg-canvas.hidden, #bg-canvas-3d.hidden {
    opacity: 0;
  }
  
  #bg-canvas.right-positioned, #bg-canvas-3d.right-positioned {
    transform: translateX(35%);
  }
  
  /* Hidden video for MediaPipe */
  #webcam {
    position: absolute;
    opacity: 0;
    pointer-events: none;
    width: 1px;
    height: 1px;
  }
</style>

<canvas id="bg-canvas"></canvas>
<canvas id="bg-canvas-3d" class="hidden"></canvas>
<video id="webcam" playsinline></video>

<script>
  import * as THREE from 'three';
  import { HandLandmarker, FilesetResolver } from "@mediapipe/tasks-vision";

  const canvas = document.getElementById('bg-canvas');
  const canvas3d = document.getElementById('bg-canvas-3d');
  const video = document.getElementById('webcam');
  
  if (!canvas || !canvas3d || !video) throw new Error('Elements not found');
  
  const ctx = canvas.getContext('2d');

  let width, height;
  let animationId;
  let currentTheme = 'cellular-automata'; 
  
  // Color customization
  let customColor = { light: 'rgba(45,45,45,0.8)', dark: 'rgba(201,169,97,0.8)' };

  // Cellular Automata State
  let grid;
  let cols, rows;
  const resolution = 20;

  // Turbulence State
  let particles = [];
  const particleCount = 500;
  let mouseX = 0;
  let mouseY = 0;
  let mouseInfluence = 0;
  
  // Differential Equation State
  let deParticles = [];
  const deParticleCount = 300;
  let time = 0;
  let selectedEquationTemplate = null;

  // Saturn State (Three.js & MediaPipe)
  let threeRenderer, threeScene, threeCamera, threeMaterial, threePoints;
  let handLandmarker = null;
  let lastVideoTime = -1;
  let isCameraRunning = false;
  let handControlValue = 0.5; // Smoothed value

  function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    
    if (threeRenderer && threeCamera) {
        threeCamera.aspect = width / height;
        threeCamera.updateProjectionMatrix();
        threeRenderer.setSize(width, height);
    }
    
    initTheme();
  }

  function initTheme() {
    // Clear 2D canvas
    if (ctx) ctx.clearRect(0, 0, width, height);

    // Toggle Canvases & Camera
    if (currentTheme === 'saturn') {
        canvas.classList.add('hidden');
        canvas3d.classList.remove('hidden');
        initSaturn();
        startCamera();
    } else {
        canvas.classList.remove('hidden');
        canvas3d.classList.add('hidden');
        stopCamera();
        
        // Cleanup Three.js if switching away
        if (threeRenderer) {
            // Optional: dispose resources
        }

        if (currentTheme === 'cellular-automata') {
            initCA();
        } else if (currentTheme === 'turbulence') {
            initTurbulence();
        } else {
            initDifferentialEquation();
        }
    }
  }

  // --- Cellular Automata (Game of Life) ---
  function initCA() {
    cols = Math.ceil(width / resolution);
    rows = Math.ceil(height / resolution);
    grid = new Array(cols).fill(null).map(() => new Array(rows).fill(null).map(() => Math.random() > 0.85 ? 1 : 0));
  }

  function drawCA() {
    const isDark = document.documentElement.classList.contains('dark');
    ctx.fillStyle = isDark ? customColor.dark : customColor.light;
    ctx.clearRect(0, 0, width, height);
    
    let next = grid.map(arr => [...arr]);

    for (let i = 0; i < cols; i++) {
      for (let j = 0; j < rows; j++) {
        let state = grid[i][j];
        if (state === 1) {
          ctx.fillRect(i * resolution, j * resolution, resolution - 1, resolution - 1);
        }

        // Count neighbors
        let sum = 0;
        let neighbors = countNeighbors(grid, i, j);

        if (state === 0 && neighbors === 3) {
          next[i][j] = 1;
        } else if (state === 1 && (neighbors < 2 || neighbors > 3)) {
          next[i][j] = 0;
        } else {
          next[i][j] = state;
        }
      }
    }
    grid = next;
  }

  function countNeighbors(grid, x, y) {
    let sum = 0;
    for (let i = -1; i < 2; i++) {
      for (let j = -1; j < 2; j++) {
        let col = (x + i + cols) % cols;
        let row = (y + j + rows) % rows;
        sum += grid[col][row];
      }
    }
    sum -= grid[x][y];
    return sum;
  }

  // --- Turbulence (Simple Flow Field) ---
  function initTurbulence() {
    particles = [];
    for(let i=0; i<particleCount; i++) {
      particles.push({
        x: Math.random() * width,
        y: Math.random() * height,
        vx: 0,
        vy: 0,
        size: Math.random() * 3 + 0.5, 
        opacity: Math.random() * 0.5 + 0.5
      });
    }
  }

  function drawTurbulence() {
    const isDark = document.documentElement.classList.contains('dark');
    ctx.fillStyle = isDark ? 'rgba(26,26,26,0.05)' : 'rgba(254,254,254,0.05)';
    ctx.fillRect(0, 0, width, height);
    
    const time = Date.now() * 0.0003;
    
    for(let p of particles) {
      const angle = (
        Math.sin(p.x * 0.003 + time) + 
        Math.cos(p.y * 0.003 + time) +
        Math.sin((p.x + p.y) * 0.002 + time * 0.5)
      ) * Math.PI;
      
      const dx = mouseX - p.x;
      const dy = mouseY - p.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const mouseForce = mouseInfluence > 0 ? Math.min(200 / (dist + 1), 5) : 0;
      
      p.vx += Math.cos(angle) * 0.15 + (dx / dist) * mouseForce * 0.1;
      p.vy += Math.sin(angle) * 0.15 + (dy / dist) * mouseForce * 0.1;
      
      p.vx *= 0.96;
      p.vy *= 0.96;
      
      p.x += p.vx;
      p.y += p.vy;
      
      if(p.x < 0) p.x = width;
      if(p.x > width) p.x = 0;
      if(p.y < 0) p.y = height;
      if(p.y > height) p.y = 0;
      
      ctx.fillStyle = isDark ? customColor.dark.replace('0.8', p.opacity) : customColor.light.replace('0.8', p.opacity);
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  // --- Differential Equation ---
  let customFunctions = null;

  function initDifferentialEquation() {
    if (ctx) ctx.clearRect(0, 0, width, height);
    deParticles = [];
    time = 0;
    
    if (!selectedEquationTemplate || (selectedEquationTemplate !== 'lorenz' && selectedEquationTemplate !== 'custom')) {
      selectedEquationTemplate = 'lorenz';
    }

    for(let i=0; i<deParticleCount; i++) {
      deParticles.push({
        x: (Math.random() - 0.5) * 20,
        y: (Math.random() - 0.5) * 20,
        z: Math.random() * 40,
        size: Math.random() * 2 + 1,
        opacity: Math.random() * 0.6 + 0.4,
      });
    }

    if (selectedEquationTemplate === 'custom') {
      try {
        const savedCustom = JSON.parse(localStorage.getItem('customEquationData'));
        if (savedCustom) {
          const createFunc = (str) => {
            let body = 'return ' + str
              .replace(/\bsin\b/g, 'Math.sin')
              .replace(/\bcos\b/g, 'Math.cos')
              .replace(/\btan\b/g, 'Math.tan')
              .replace(/\babs\b/g, 'Math.abs')
              .replace(/\bsqrt\b/g, 'Math.sqrt')
              .replace(/\bpow\b/g, 'Math.pow')
              .replace(/\bPI\b/g, 'Math.PI');
            return new Function('x', 'y', 'z', 't', body);
          };
          customFunctions = {
            dx: createFunc(savedCustom.dx),
            dy: createFunc(savedCustom.dy),
            dz: createFunc(savedCustom.dz)
          };
        } else {
          selectedEquationTemplate = 'lorenz';
        }
      } catch (e) {
        selectedEquationTemplate = 'lorenz';
      }
    }
  }
  
  function drawDifferentialEquation() {
    const isDark = document.documentElement.classList.contains('dark');
    ctx.fillStyle = isDark ? 'rgba(26,26,26,0.03)' : 'rgba(254,254,254,0.03)';
    ctx.fillRect(0, 0, width, height);
    
    const dt = 0.005;
    
    if (selectedEquationTemplate === 'lorenz') {
      const sigma = 10;
      const rho = 28;
      const beta = 8/3;
      
      for(let p of deParticles) {
        const dx = sigma * (p.y - p.x) * dt;
        const dy = (p.x * (rho - p.z) - p.y) * dt;
        const dz = (p.x * p.y - beta * p.z) * dt;
        
        p.x += dx;
        p.y += dy;
        p.z += dz;
        
        const scale = 8;
        const screenX = width / 2 + p.x * scale;
        const screenY = height / 2 + p.y * scale;
        
        ctx.fillStyle = isDark ? customColor.dark.replace('0.8', p.opacity) : customColor.light.replace('0.8', p.opacity);
        ctx.beginPath();
        ctx.arc(screenX, screenY, p.size, 0, Math.PI * 2);
        ctx.fill();
        
        if (Math.abs(p.x) > 30 || Math.abs(p.y) > 30 || p.z > 60 || p.z < 0) {
          p.x = (Math.random() - 0.5) * 20;
          p.y = (Math.random() - 0.5) * 20;
          p.z = Math.random() * 40;
        }
      }
    } else if (selectedEquationTemplate === 'custom' && customFunctions) {
      for(let p of deParticles) {
        try {
          const dx = customFunctions.dx(p.x, p.y, p.z, time) * dt;
          const dy = customFunctions.dy(p.x, p.y, p.z, time) * dt;
          const dz = customFunctions.dz(p.x, p.y, p.z, time) * dt;
          
          p.x += dx;
          p.y += dy;
          p.z += dz;
          
          const scale = 8; 
          const screenX = width / 2 + p.x * scale;
          const screenY = height / 2 + p.y * scale;
          
          ctx.fillStyle = isDark ? customColor.dark.replace('0.8', p.opacity) : customColor.light.replace('0.8', p.opacity);
          ctx.beginPath();
          ctx.arc(screenX, screenY, p.size, 0, Math.PI * 2);
          ctx.fill();
          
          if (Math.abs(p.x) > 50 || Math.abs(p.y) > 50 || Math.abs(p.z) > 100 || isNaN(p.x)) {
             p.x = (Math.random() - 0.5) * 20;
             p.y = (Math.random() - 0.5) * 20;
             p.z = Math.random() * 40;
          }
        } catch (e) {
          selectedEquationTemplate = 'lorenz'; 
          initDifferentialEquation();
          break;
        }
      }
    }
    time += dt;
  }

  // --- MediaPipe & Camera ---
  async function initMediaPipe() {
    if (handLandmarker) return;
    
    try {
        const vision = await FilesetResolver.forVisionTasks(
            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
        );
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
            baseOptions: {
                modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                delegate: "GPU"
            },
            runningMode: "VIDEO",
            numHands: 2
        });
    } catch (e) {
        console.error("Failed to init MediaPipe:", e);
    }
  }

  async function startCamera() {
    if (isCameraRunning) return;
    
    await initMediaPipe();
    
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = stream;
        video.addEventListener("loadeddata", () => {
            isCameraRunning = true;
            video.play();
        });
    } catch (err) {
        console.warn("Camera access denied or not available. Falling back to mouse.", err);
    }
  }

  function stopCamera() {
    if (!isCameraRunning) return;
    
    if (video.srcObject) {
        const tracks = video.srcObject.getTracks();
        tracks.forEach(track => track.stop());
        video.srcObject = null;
    }
    isCameraRunning = false;
  }

  // --- Saturn (Three.js) ---
  function initSaturn() {
    if (!threeRenderer) {
        threeScene = new THREE.Scene();
        threeCamera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
        threeCamera.position.z = 15;
        threeCamera.position.y = 5;
        threeCamera.lookAt(0, 0, 0);

        threeRenderer = new THREE.WebGLRenderer({ canvas: canvas3d, alpha: true, antialias: true });
        threeRenderer.setSize(width, height);
        threeRenderer.setPixelRatio(window.devicePixelRatio);
    }
    
    // Clear existing children
    while(threeScene.children.length > 0){ 
        threeScene.remove(threeScene.children[0]); 
    }

    const PARTICLE_COUNT = 40000;
    const SATURN_RADIUS = 2;
    const RING_INNER = 3;
    const RING_OUTER = 8;

    const geometry = new THREE.BufferGeometry();
    const positions = [];
    const sizes = [];
    const speeds = [];
    const angleOffsets = [];
    const radii = [];
    const isRings = [];
    const initialPos = [];

    for (let i = 0; i < PARTICLE_COUNT; i++) {
        let x, y, z, r, isRingVal;
        
        if (Math.random() < 0.4) {
            // Core
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const rad = Math.pow(Math.random(), 1/3) * SATURN_RADIUS;
            x = rad * Math.sin(phi) * Math.cos(theta);
            y = rad * Math.sin(phi) * Math.sin(theta);
            z = rad * Math.cos(phi);
            r = Math.sqrt(x*x + z*z);
            isRingVal = 0.0;
        } else {
            // Ring
            const theta = Math.random() * Math.PI * 2;
            const rad = RING_INNER + Math.random() * (RING_OUTER - RING_INNER);
            x = rad * Math.cos(theta);
            y = (Math.random() - 0.5) * 0.2;
            z = rad * Math.sin(theta);
            r = rad;
            isRingVal = 1.0;
        }

        positions.push(x, y, z);
        initialPos.push(x, y, z);
        sizes.push(Math.random() * 2.0 + 0.5);
        speeds.push(Math.random() * 0.5 + 0.5);
        angleOffsets.push(Math.atan2(z, x));
        radii.push(r);
        isRings.push(isRingVal);
    }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('initialPos', new THREE.Float32BufferAttribute(initialPos, 3));
    geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
    geometry.setAttribute('speed', new THREE.Float32BufferAttribute(speeds, 1));
    geometry.setAttribute('angleOffset', new THREE.Float32BufferAttribute(angleOffsets, 1));
    geometry.setAttribute('radius', new THREE.Float32BufferAttribute(radii, 1));
    geometry.setAttribute('isRing', new THREE.Float32BufferAttribute(isRings, 1));

    // Shader
    const vertexShader = `
      uniform float time;
      uniform float handControl; 
      uniform float chaosLevel;
      uniform vec3 colorCore;
      uniform vec3 colorRing;
      
      attribute float size;
      attribute float speed;
      attribute float angleOffset;
      attribute float radius;
      attribute vec3 initialPos;
      attribute float isRing;

      varying vec3 vColor;
      varying float vAlpha;

      float random(vec2 st) {
          return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
      }

      void main() {
        float currentRadius = radius;
        // Hand control affects scale: 0.5 (closed) to 2.0 (open)
        float scaleFactor = 0.5 + 1.5 * handControl; 
        currentRadius *= scaleFactor;

        float w = speed * 0.5;
        if (isRing > 0.5) {
           w = 2.0 * pow(currentRadius, -1.5); 
        }
        
        float currentAngle = angleOffset + w * time;

        vec3 pos;
        if (isRing > 0.5) {
            pos = vec3(
                currentRadius * cos(currentAngle),
                (random(vec2(radius, angleOffset)) - 0.5) * 0.2 * scaleFactor,
                currentRadius * sin(currentAngle)
            );
        } else {
            float c = cos(time * 0.5);
            float s = sin(time * 0.5);
            pos = vec3(
                initialPos.x * c - initialPos.z * s,
                initialPos.y,
                initialPos.x * s + initialPos.z * c
            ) * scaleFactor;
        }

        if (chaosLevel > 0.0) {
            vec3 noise = vec3(
                random(vec2(time, float(gl_VertexID))) - 0.5,
                random(vec2(time + 1.0, float(gl_VertexID))) - 0.5,
                random(vec2(time + 2.0, float(gl_VertexID))) - 0.5
            );
            pos += noise * chaosLevel * 2.0;
        }

        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
        gl_Position = projectionMatrix * mvPosition;
        gl_PointSize = size * (300.0 / -mvPosition.z);

        // Color Logic
        if (isRing > 0.5) {
            vColor = colorRing;
            vAlpha = 0.6;
        } else {
            vColor = colorCore;
            vAlpha = 0.9;
        }
        
        if (-mvPosition.z < 1.0) vAlpha = 0.0;
      }
    `;

    const fragmentShader = `
      varying vec3 vColor;
      varying float vAlpha;
      void main() {
        vec2 coord = gl_PointCoord - vec2(0.5);
        if(length(coord) > 0.5) discard;
        float strength = 1.0 - (length(coord) * 2.0);
        strength = pow(strength, 2.0);
        gl_FragColor = vec4(vColor, vAlpha * strength);
      }
    `;

    threeMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          handControl: { value: 0.5 },
          chaosLevel: { value: 0.0 },
          colorCore: { value: new THREE.Color(0x00aaff) }, // Default Blue
          colorRing: { value: new THREE.Color(0x0055aa) }
        },
        vertexShader,
        fragmentShader,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending
    });

    threePoints = new THREE.Points(geometry, threeMaterial);
    threeScene.add(threePoints);
  }

  function drawSaturn() {
    if (!threeRenderer || !threeMaterial) return;

    const time = performance.now() * 0.001;
    threeMaterial.uniforms.time.value = time;

    // --- Hand Tracking Logic ---
    let targetControl = 0.5;
    let handsDetected = false;

    if (isCameraRunning && handLandmarker && video.readyState >= 2) {
         if (video.currentTime !== lastVideoTime) {
             lastVideoTime = video.currentTime;
             const detections = handLandmarker.detectForVideo(video, performance.now());
             
             if (detections.landmarks && detections.landmarks.length > 0) {
                 handsDetected = true;
                 
                 // Calculate average "openness" of all detected hands
                 let totalOpenness = 0;
                 
                 for (const landmarks of detections.landmarks) {
                     // Simple openness: Distance between Thumb Tip (4) and Index Tip (8)
                     // Normalized somewhat arbitrarily
                     const thumb = landmarks[4];
                     const index = landmarks[8];
                     const dist = Math.sqrt(
                         Math.pow(thumb.x - index.x, 2) + 
                         Math.pow(thumb.y - index.y, 2) + 
                         Math.pow(thumb.z - index.z, 2)
                     );
                     
                     // Map 0.02 (closed) -> 0.2 (open) to 0..1
                     let val = (dist - 0.02) / (0.15 - 0.02);
                     val = Math.max(0, Math.min(1, val));
                     totalOpenness += val;
                 }
                 
                 targetControl = totalOpenness / detections.landmarks.length;
             }
         }
    }

    // Fallback to mouse if no hands detected
    if (!handsDetected) {
        targetControl = Math.max(0, Math.min(1, mouseX / width));
    }
    
    // Smooth interpolation
    handControlValue += (targetControl - handControlValue) * 0.1;
    threeMaterial.uniforms.handControl.value = handControlValue;

    // Chaos
    if (handControlValue > 0.85) {
        threeMaterial.uniforms.chaosLevel.value = (handControlValue - 0.85) * 6.0;
    } else {
        threeMaterial.uniforms.chaosLevel.value = 0.0;
    }
    
    // Update colors based on customColor
    // Parse rgba string to THREE.Color
    // We use a helper since THREE.Color(string) supports CSS colors
    const isDark = document.documentElement.classList.contains('dark');
    const colorStr = isDark ? customColor.dark : customColor.light;
    
    // Use the theme color for the Core, and a dimmer version for the Ring
    const baseColor = new THREE.Color(colorStr);
    threeMaterial.uniforms.colorCore.value.lerp(baseColor, 0.1);
    
    const ringColor = baseColor.clone().multiplyScalar(0.5); // Dimmer
    threeMaterial.uniforms.colorRing.value.lerp(ringColor, 0.1);

    threeRenderer.render(threeScene, threeCamera);
  }

  function animate() {
    if (currentTheme === 'cellular-automata') {
      if (Date.now() % 100 < 20) drawCA(); 
    } else if (currentTheme === 'turbulence') {
      drawTurbulence();
    } else if (currentTheme === 'differential-equation') {
      drawDifferentialEquation();
    } else if (currentTheme === 'saturn') {
      drawSaturn();
    }
    animationId = requestAnimationFrame(animate);
  }

  window.addEventListener('resize', resize);
  resize();
  animate();
  
  window.addEventListener('mousemove', (e) => {
    mouseX = e.clientX;
    mouseY = e.clientY;
    mouseInfluence = 1;
  });
  
  setInterval(() => {
    mouseInfluence *= 0.95;
  }, 50);

  window.addEventListener('theme-change', (e) => {
    currentTheme = e.detail.theme;
    initTheme();
    updateCanvasPosition();
  });
  
  window.addEventListener('color-change', (e) => {
    customColor = e.detail;
  });
  
  window.addEventListener('equation-selected', (e) => {
    const detail = e.detail;
    if (detail.type === 'custom') {
      selectedEquationTemplate = 'custom';
      localStorage.setItem('selectedEquation', 'custom');
      localStorage.setItem('customEquationData', JSON.stringify(detail.data));
    } else {
      selectedEquationTemplate = 'lorenz';
      localStorage.setItem('selectedEquation', 'lorenz');
    }
    if (currentTheme === 'differential-equation') {
      initDifferentialEquation();
    }
  });
  
  const savedEquation = localStorage.getItem('selectedEquation');
  if (savedEquation) {
    selectedEquationTemplate = savedEquation;
  }
  
  function updateCanvasPosition() {
    const isHomepage = window.location.pathname === '/' || window.location.pathname === '/index.html';
    
    if (!isHomepage && currentTheme === 'differential-equation') {
      canvas.classList.add('right-positioned');
      canvas3d.classList.add('right-positioned');
    } else {
      canvas.classList.remove('right-positioned');
      canvas3d.classList.remove('right-positioned');
    }
  }
  
  updateCanvasPosition();
  window.addEventListener('theme-change', updateCanvasPosition);
  
  if (document.addEventListener) {
    document.addEventListener('astro:page-load', updateCanvasPosition);
  }

</script>
