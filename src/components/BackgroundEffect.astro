<style>
  #bg-canvas, #bg-canvas-3d {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    opacity: 0.25;
    pointer-events: none;
    transition: opacity 0.5s ease;
  }
  
  #bg-canvas.hidden, #bg-canvas-3d.hidden {
    opacity: 0;
  }
  
  #bg-canvas.right-positioned, #bg-canvas-3d.right-positioned {
    transform: translateX(35%);
  }
  
  /* Hidden video for MediaPipe */
  #webcam {
    position: absolute;
    opacity: 0;
    pointer-events: none;
    width: 1px;
    height: 1px;
  }
</style>

<!-- Saturn Settings Modal -->
<div id="saturn-settings-modal" class="fixed inset-0 bg-black/50 hidden items-center justify-center z-50 backdrop-blur-sm">
  <div class="bg-white dark:bg-gray-900 p-6 rounded-xl shadow-2xl w-80 border border-gray-200 dark:border-gray-700">
    <div class="flex justify-between items-center mb-4">
      <h3 class="text-lg font-bold text-gray-800 dark:text-gray-200">Saturn Settings</h3>
      <button id="close-saturn-settings" class="text-gray-500 hover:text-gray-700 dark:hover:text-gray-300">
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
      </button>
    </div>
    
    <div class="space-y-4">
      <div>
        <label class="block text-xs font-medium text-gray-500 dark:text-gray-400 mb-1">Particle Count</label>
        <input type="range" id="saturn-particle-count" min="5000" max="50000" step="1000" value="18000" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700">
        <div class="text-right text-xs text-gray-500" id="saturn-particle-count-val">18000</div>
      </div>
      
      <div>
        <label class="block text-xs font-medium text-gray-500 dark:text-gray-400 mb-1">Rotation Speed</label>
        <input type="range" id="saturn-speed" min="0.1" max="2.0" step="0.1" value="1.0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700">
        <div class="text-right text-xs text-gray-500" id="saturn-speed-val">1.0x</div>
      </div>
      
      <div>
        <label class="block text-xs font-medium text-gray-500 dark:text-gray-400 mb-1">Chaos Intensity</label>
        <input type="range" id="saturn-chaos" min="0.1" max="2.0" step="0.1" value="0.8" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700">
        <div class="text-right text-xs text-gray-500" id="saturn-chaos-val">0.8</div>
      </div>
    </div>
  </div>
</div>

<canvas id="bg-canvas"></canvas>
<canvas id="bg-canvas-3d" class="hidden"></canvas>
<video id="webcam" playsinline></video>

<script>
  import * as THREE from 'three';
  import { HandLandmarker, FilesetResolver } from "@mediapipe/tasks-vision";

  const canvas = document.getElementById('bg-canvas');
  const canvas3d = document.getElementById('bg-canvas-3d');
  const video = document.getElementById('webcam');
  
  if (!canvas || !canvas3d || !video) throw new Error('Elements not found');
  
  const ctx = canvas.getContext('2d');

  let width, height;
  let animationId;
  let currentTheme = 'cellular-automata'; 
  
  // Color customization
  let customColor = { light: 'rgba(45,45,45,0.8)', dark: 'rgba(201,169,97,0.8)' };

  // Cellular Automata State
  let grid;
  let cols, rows;
  const resolution = 20;

  // Turbulence State
  let particles = [];
  const particleCount = 500;
  let mouseX = 0;
  let mouseY = 0;
  let mouseInfluence = 0;
  
  // Differential Equation State
  let deParticles = [];
  const deParticleCount = 300;
  let time = 0;
  let selectedEquationTemplate = null;

  // Saturn State (Three.js & MediaPipe)
  let threeRenderer, threeScene, threeCamera, threeMaterial, threePoints;
  let handLandmarker = null;
  let lastVideoTime = -1;
  let isCameraRunning = false;
  let handControlValue = 0.5; // Smoothed value
  
  // Saturn Settings
  let saturnSettings = {
    particleCount: 18000,
    speedMultiplier: 1.0,
    chaosMultiplier: 0.8
  };

  function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    
    if (threeRenderer && threeCamera) {
        threeCamera.aspect = width / height;
        threeCamera.updateProjectionMatrix();
        threeRenderer.setSize(width, height);
    }
    
    initTheme();
  }

  function initTheme() {
    // Clear 2D canvas
    if (ctx) ctx.clearRect(0, 0, width, height);

    // Toggle Canvases & Camera
    if (currentTheme === 'saturn') {
        canvas.classList.add('hidden');
        canvas3d.classList.remove('hidden');
        initSaturn();
        startCamera();
    } else {
        canvas.classList.remove('hidden');
        canvas3d.classList.add('hidden');
        stopCamera();
        
        // Cleanup Three.js if switching away
        if (threeRenderer) {
            // Optional: dispose resources
        }

        if (currentTheme === 'cellular-automata') {
            initCA();
        } else if (currentTheme === 'turbulence') {
            initTurbulence();
        } else {
            initDifferentialEquation();
        }
    }
  }

  // --- Cellular Automata (Game of Life) ---
  function initCA() {
    cols = Math.ceil(width / resolution);
    rows = Math.ceil(height / resolution);
    grid = new Array(cols).fill(null).map(() => new Array(rows).fill(null).map(() => Math.random() > 0.85 ? 1 : 0));
  }

  function drawCA() {
    const isDark = document.documentElement.classList.contains('dark');
    ctx.fillStyle = isDark ? customColor.dark : customColor.light;
    ctx.clearRect(0, 0, width, height);
    
    let next = grid.map(arr => [...arr]);

    for (let i = 0; i < cols; i++) {
      for (let j = 0; j < rows; j++) {
        let state = grid[i][j];
        if (state === 1) {
          ctx.fillRect(i * resolution, j * resolution, resolution - 1, resolution - 1);
        }

        // Count neighbors
        let sum = 0;
        let neighbors = countNeighbors(grid, i, j);

        if (state === 0 && neighbors === 3) {
          next[i][j] = 1;
        } else if (state === 1 && (neighbors < 2 || neighbors > 3)) {
          next[i][j] = 0;
        } else {
          next[i][j] = state;
        }
      }
    }
    grid = next;
  }

  function countNeighbors(grid, x, y) {
    let sum = 0;
    for (let i = -1; i < 2; i++) {
      for (let j = -1; j < 2; j++) {
        let col = (x + i + cols) % cols;
        let row = (y + j + rows) % rows;
        sum += grid[col][row];
      }
    }
    sum -= grid[x][y];
    return sum;
  }

  // --- Turbulence (Simple Flow Field) ---
  function initTurbulence() {
    particles = [];
    for(let i=0; i<particleCount; i++) {
      particles.push({
        x: Math.random() * width,
        y: Math.random() * height,
        vx: 0,
        vy: 0,
        size: Math.random() * 3 + 0.5, 
        opacity: Math.random() * 0.5 + 0.5
      });
    }
  }

  function drawTurbulence() {
    const isDark = document.documentElement.classList.contains('dark');
    ctx.fillStyle = isDark ? 'rgba(26,26,26,0.05)' : 'rgba(254,254,254,0.05)';
    ctx.fillRect(0, 0, width, height);
    
    const time = Date.now() * 0.0003;
    
    for(let p of particles) {
      const angle = (
        Math.sin(p.x * 0.003 + time) + 
        Math.cos(p.y * 0.003 + time) +
        Math.sin((p.x + p.y) * 0.002 + time * 0.5)
      ) * Math.PI;
      
      const dx = mouseX - p.x;
      const dy = mouseY - p.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const mouseForce = mouseInfluence > 0 ? Math.min(200 / (dist + 1), 5) : 0;
      
      p.vx += Math.cos(angle) * 0.15 + (dx / dist) * mouseForce * 0.1;
      p.vy += Math.sin(angle) * 0.15 + (dy / dist) * mouseForce * 0.1;
      
      p.vx *= 0.96;
      p.vy *= 0.96;
      
      p.x += p.vx;
      p.y += p.vy;
      
      if(p.x < 0) p.x = width;
      if(p.x > width) p.x = 0;
      if(p.y < 0) p.y = height;
      if(p.y > height) p.y = 0;
      
      ctx.fillStyle = isDark ? customColor.dark.replace('0.8', p.opacity) : customColor.light.replace('0.8', p.opacity);
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  // --- Differential Equation ---
  let customFunctions = null;

  function initDifferentialEquation() {
    if (ctx) ctx.clearRect(0, 0, width, height);
    deParticles = [];
    time = 0;
    
    if (!selectedEquationTemplate || (selectedEquationTemplate !== 'lorenz' && selectedEquationTemplate !== 'custom')) {
      selectedEquationTemplate = 'lorenz';
    }

    for(let i=0; i<deParticleCount; i++) {
      deParticles.push({
        x: (Math.random() - 0.5) * 20,
        y: (Math.random() - 0.5) * 20,
        z: Math.random() * 40,
        size: Math.random() * 2 + 1,
        opacity: Math.random() * 0.6 + 0.4,
      });
    }

    if (selectedEquationTemplate === 'custom') {
      try {
        const savedCustom = JSON.parse(localStorage.getItem('customEquationData'));
        if (savedCustom) {
          const createFunc = (str) => {
            let body = 'return ' + str
              .replace(/\bsin\b/g, 'Math.sin')
              .replace(/\bcos\b/g, 'Math.cos')
              .replace(/\btan\b/g, 'Math.tan')
              .replace(/\babs\b/g, 'Math.abs')
              .replace(/\bsqrt\b/g, 'Math.sqrt')
              .replace(/\bpow\b/g, 'Math.pow')
              .replace(/\bPI\b/g, 'Math.PI');
            return new Function('x', 'y', 'z', 't', body);
          };
          customFunctions = {
            dx: createFunc(savedCustom.dx),
            dy: createFunc(savedCustom.dy),
            dz: createFunc(savedCustom.dz)
          };
        } else {
          selectedEquationTemplate = 'lorenz';
        }
      } catch (e) {
        selectedEquationTemplate = 'lorenz';
      }
    }
  }
  
  function drawDifferentialEquation() {
    const isDark = document.documentElement.classList.contains('dark');
    ctx.fillStyle = isDark ? 'rgba(26,26,26,0.03)' : 'rgba(254,254,254,0.03)';
    ctx.fillRect(0, 0, width, height);
    
    const dt = 0.005;
    
    if (selectedEquationTemplate === 'lorenz') {
      const sigma = 10;
      const rho = 28;
      const beta = 8/3;
      
      for(let p of deParticles) {
        const dx = sigma * (p.y - p.x) * dt;
        const dy = (p.x * (rho - p.z) - p.y) * dt;
        const dz = (p.x * p.y - beta * p.z) * dt;
        
        p.x += dx;
        p.y += dy;
        p.z += dz;
        
        const scale = 8;
        const screenX = width / 2 + p.x * scale;
        const screenY = height / 2 + p.y * scale;
        
        ctx.fillStyle = isDark ? customColor.dark.replace('0.8', p.opacity) : customColor.light.replace('0.8', p.opacity);
        ctx.beginPath();
        ctx.arc(screenX, screenY, p.size, 0, Math.PI * 2);
        ctx.fill();
        
        if (Math.abs(p.x) > 30 || Math.abs(p.y) > 30 || p.z > 60 || p.z < 0) {
          p.x = (Math.random() - 0.5) * 20;
          p.y = (Math.random() - 0.5) * 20;
          p.z = Math.random() * 40;
        }
      }
    } else if (selectedEquationTemplate === 'custom' && customFunctions) {
      for(let p of deParticles) {
        try {
          const dx = customFunctions.dx(p.x, p.y, p.z, time) * dt;
          const dy = customFunctions.dy(p.x, p.y, p.z, time) * dt;
          const dz = customFunctions.dz(p.x, p.y, p.z, time) * dt;
          
          p.x += dx;
          p.y += dy;
          p.z += dz;
          
          const scale = 8; 
          const screenX = width / 2 + p.x * scale;
          const screenY = height / 2 + p.y * scale;
          
          ctx.fillStyle = isDark ? customColor.dark.replace('0.8', p.opacity) : customColor.light.replace('0.8', p.opacity);
          ctx.beginPath();
          ctx.arc(screenX, screenY, p.size, 0, Math.PI * 2);
          ctx.fill();
          
          if (Math.abs(p.x) > 50 || Math.abs(p.y) > 50 || Math.abs(p.z) > 100 || isNaN(p.x)) {
             p.x = (Math.random() - 0.5) * 20;
             p.y = (Math.random() - 0.5) * 20;
             p.z = Math.random() * 40;
          }
        } catch (e) {
          selectedEquationTemplate = 'lorenz'; 
          initDifferentialEquation();
          break;
        }
      }
    }
    time += dt;
  }

  // --- MediaPipe & Camera ---
  async function initMediaPipe() {
    if (handLandmarker) return;
    
    try {
        const vision = await FilesetResolver.forVisionTasks(
            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
        );
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
            baseOptions: {
                modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                delegate: "GPU"
            },
            runningMode: "VIDEO",
            numHands: 2
        });
    } catch (e) {
        console.error("Failed to init MediaPipe:", e);
    }
  }

  async function startCamera() {
    if (isCameraRunning) return;
    
    await initMediaPipe();
    
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = stream;
        video.addEventListener("loadeddata", () => {
            isCameraRunning = true;
            video.play();
        });
    } catch (err) {
        console.warn("Camera access denied or not available. Falling back to mouse.", err);
    }
  }

  function stopCamera() {
    if (!isCameraRunning) return;
    
    if (video.srcObject) {
        const tracks = video.srcObject.getTracks();
        tracks.forEach(track => track.stop());
        video.srcObject = null;
    }
    isCameraRunning = false;
  }

  // --- Saturn (Three.js) ---
  function initSaturn() {
    if (!threeRenderer) {
        threeScene = new THREE.Scene();
        threeCamera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
        threeCamera.position.z = 15;
        threeCamera.position.y = 5;
        threeCamera.lookAt(0, 0, 0);

        threeRenderer = new THREE.WebGLRenderer({ canvas: canvas3d, alpha: true, antialias: true });
        threeRenderer.setSize(width, height);
        threeRenderer.setPixelRatio(window.devicePixelRatio);
    }
    
    // Clear existing children
    while(threeScene.children.length > 0){ 
        threeScene.remove(threeScene.children[0]); 
    }

    const PARTICLE_COUNT = saturnSettings.particleCount;
    const SATURN_RADIUS = 1.8;
    const RING_INNER = 2.8;
    const RING_OUTER = 7;

    const geometry = new THREE.BufferGeometry();
    const positions = [];
    const sizes = [];
    const speeds = [];
    const angleOffsets = [];
    const radii = [];
    const isRings = [];
    const initialPos = [];

    for (let i = 0; i < PARTICLE_COUNT; i++) {
        let x, y, z, r, isRingVal;
        
        if (Math.random() < 0.35) {
            // Core
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const rad = Math.pow(Math.random(), 1/3) * SATURN_RADIUS;
            x = rad * Math.sin(phi) * Math.cos(theta);
            y = rad * Math.sin(phi) * Math.sin(theta);
            z = rad * Math.cos(phi);
            r = Math.sqrt(x*x + z*z);
            isRingVal = 0.0;
        } else {
            // Ring
            const theta = Math.random() * Math.PI * 2;
            const rad = RING_INNER + Math.random() * (RING_OUTER - RING_INNER);
            x = rad * Math.cos(theta);
            y = (Math.random() - 0.5) * 0.15;
            z = rad * Math.sin(theta);
            r = rad;
            isRingVal = 1.0;
        }

        positions.push(x, y, z);
        initialPos.push(x, y, z);
        sizes.push(Math.random() * 1.2 + 0.3);
        speeds.push(Math.random() * 0.3 + 0.3);
        angleOffsets.push(Math.atan2(z, x));
        radii.push(r);
        isRings.push(isRingVal);
    }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('initialPos', new THREE.Float32BufferAttribute(initialPos, 3));
    geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
    geometry.setAttribute('speed', new THREE.Float32BufferAttribute(speeds, 1));
    geometry.setAttribute('angleOffset', new THREE.Float32BufferAttribute(angleOffsets, 1));
    geometry.setAttribute('radius', new THREE.Float32BufferAttribute(radii, 1));
    geometry.setAttribute('isRing', new THREE.Float32BufferAttribute(isRings, 1));

    // Shader
    const vertexShader = `
      uniform float time;
      uniform float handControl; 
      uniform float chaosLevel;
      uniform float speedMultiplier;
      uniform vec3 colorCore;
      uniform vec3 colorRing;
      
      attribute float size;
      attribute float speed;
      attribute float angleOffset;
      attribute float radius;
      attribute vec3 initialPos;
      attribute float isRing;

      varying vec3 vColor;
      varying float vAlpha;

      float random(vec2 st) {
          return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
      }

      void main() {
        float currentRadius = radius;
        // Hand control affects scale: 0.5 (closed) to 2.0 (open)
        float scaleFactor = 0.5 + 1.5 * handControl; 
        currentRadius *= scaleFactor;

        float w = speed * 0.5 * speedMultiplier;
        if (isRing > 0.5) {
           w = 2.0 * pow(currentRadius, -1.5) * speedMultiplier; 
        }
        
        float currentAngle = angleOffset + w * time;

        vec3 pos;
        if (isRing > 0.5) {
            pos = vec3(
                currentRadius * cos(currentAngle),
                (random(vec2(radius, angleOffset)) - 0.5) * 0.2 * scaleFactor,
                currentRadius * sin(currentAngle)
            );
        } else {
            float c = cos(time * 0.5);
            float s = sin(time * 0.5);
            pos = vec3(
                initialPos.x * c - initialPos.z * s,
                initialPos.y,
                initialPos.x * s + initialPos.z * c
            ) * scaleFactor;
        }

        if (chaosLevel > 0.0) {
            // Slower Brownian motion - use slower time frequency
            float slowTime = time * 0.15; // Even slower time
            vec3 noise = vec3(
                random(vec2(slowTime, float(gl_VertexID))) - 0.5,
                random(vec2(slowTime + 1.0, float(gl_VertexID))) - 0.5,
                random(vec2(slowTime + 2.0, float(gl_VertexID))) - 0.5
            );
            pos += noise * chaosLevel;
        }

        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
        gl_Position = projectionMatrix * mvPosition;
        gl_PointSize = size * (200.0 / -mvPosition.z);

        // Color Logic - Cosmic calm
        if (isRing > 0.5) {
            vColor = colorRing;
            vAlpha = 0.6; // Increased from 0.35 for better visibility
        } else {
            vColor = colorCore;
            vAlpha = 0.8; // Increased from 0.5
        }
        
        if (-mvPosition.z < 1.0) vAlpha = 0.0;
      }
    `;

    const fragmentShader = `
      varying vec3 vColor;
      varying float vAlpha;
      void main() {
        vec2 coord = gl_PointCoord - vec2(0.5);
        if(length(coord) > 0.5) discard;
        float strength = 1.0 - (length(coord) * 2.0);
        strength = pow(strength, 2.0);
        gl_FragColor = vec4(vColor, vAlpha * strength);
      }
    `;

    threeMaterial = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          handControl: { value: 0.5 },
          chaosLevel: { value: 0.0 },
          speedMultiplier: { value: saturnSettings.speedMultiplier },
          colorCore: { value: new THREE.Color(0x6080a0) }, 
          colorRing: { value: new THREE.Color(0x405060) }  
        },
        vertexShader,
        fragmentShader,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending
    });

    threePoints = new THREE.Points(geometry, threeMaterial);
    threeScene.add(threePoints);
  }

  function drawSaturn() {
    if (!threeRenderer || !threeMaterial) return;

    const time = performance.now() * 0.001;
    threeMaterial.uniforms.time.value = time;

    // --- Hand Tracking Logic ---
    let targetControl = 0.5;
    let handsDetected = false;

    if (isCameraRunning && handLandmarker && video.readyState >= 2) {
         if (video.currentTime !== lastVideoTime) {
             lastVideoTime = video.currentTime;
             const detections = handLandmarker.detectForVideo(video, performance.now());
             
             if (detections.landmarks && detections.landmarks.length > 0) {
                 handsDetected = true;
                 
                 // Calculate average "openness" of all detected hands
                 let totalOpenness = 0;
                 
                 for (const landmarks of detections.landmarks) {
                     // Simple openness: Distance between Thumb Tip (4) and Index Tip (8)
                     // Normalized somewhat arbitrarily
                     const thumb = landmarks[4];
                     const index = landmarks[8];
                     const dist = Math.sqrt(
                         Math.pow(thumb.x - index.x, 2) + 
                         Math.pow(thumb.y - index.y, 2) + 
                         Math.pow(thumb.z - index.z, 2)
                     );
                     
                     // Map 0.02 (closed) -> 0.2 (open) to 0..1
                     let val = (dist - 0.02) / (0.15 - 0.02);
                     val = Math.max(0, Math.min(1, val));
                     totalOpenness += val;
                 }
                 
                 targetControl = totalOpenness / detections.landmarks.length;
             }
         }
    }

    // Fallback to mouse if no hands detected
    if (!handsDetected) {
        targetControl = Math.max(0, Math.min(1, mouseX / width));
    }
    
    // Smooth interpolation
    handControlValue += (targetControl - handControlValue) * 0.1;
    threeMaterial.uniforms.handControl.value = handControlValue;

    // Chaos
    if (handControlValue > 0.85) {
        threeMaterial.uniforms.chaosLevel.value = (handControlValue - 0.85) * 6.0 * saturnSettings.chaosMultiplier;
    } else {
        threeMaterial.uniforms.chaosLevel.value = 0.0;
    }
    
    // Update colors based on customColor
    // Parse rgba string to THREE.Color
    const isDark = document.documentElement.classList.contains('dark');
    const colorStr = isDark ? customColor.dark : customColor.light;
    
    // Use a desaturated, cooler version of the theme color
    const baseColor = new THREE.Color(colorStr);
    // Desaturate and cool down the color for cosmic feel
    const h = baseColor.getHSL({}).h;
    
    // Brighter in dark mode
    const lCore = isDark ? 0.6 : 0.4;
    const lRing = isDark ? 0.4 : 0.25;
    
    const coreColor = new THREE.Color().setHSL(h, 0.4, lCore); // Increased saturation and lightness
    const ringColor = new THREE.Color().setHSL(h, 0.3, lRing); 
    
    threeMaterial.uniforms.colorCore.value.lerp(coreColor, 0.05);
    threeMaterial.uniforms.colorRing.value.lerp(ringColor, 0.05);

    threeRenderer.render(threeScene, threeCamera);
  }

  function animate() {
    if (currentTheme === 'cellular-automata') {
      if (Date.now() % 100 < 20) drawCA(); 
    } else if (currentTheme === 'turbulence') {
      drawTurbulence();
    } else if (currentTheme === 'differential-equation') {
      drawDifferentialEquation();
    } else if (currentTheme === 'saturn') {
      drawSaturn();
    }
    animationId = requestAnimationFrame(animate);
  }

  window.addEventListener('resize', resize);
  resize();
  animate();
  
  window.addEventListener('mousemove', (e) => {
    mouseX = e.clientX;
    mouseY = e.clientY;
    mouseInfluence = 1;
  });
  
  setInterval(() => {
    mouseInfluence *= 0.95;
  }, 50);

  window.addEventListener('theme-change', (e) => {
    currentTheme = e.detail.theme;
    initTheme();
    updateCanvasPosition();
  });
  
  window.addEventListener('color-change', (e) => {
    customColor = e.detail;
  });
  
  window.addEventListener('equation-selected', (e) => {
    const detail = e.detail;
    if (detail.type === 'custom') {
      selectedEquationTemplate = 'custom';
      localStorage.setItem('selectedEquation', 'custom');
      localStorage.setItem('customEquationData', JSON.stringify(detail.data));
    } else {
      selectedEquationTemplate = 'lorenz';
      localStorage.setItem('selectedEquation', 'lorenz');
    }
    if (currentTheme === 'differential-equation') {
      initDifferentialEquation();
    }
  });
  
  const savedEquation = localStorage.getItem('selectedEquation');
  if (savedEquation) {
    selectedEquationTemplate = savedEquation;
  }
  
  function updateCanvasPosition() {
    const isHomepage = window.location.pathname === '/' || window.location.pathname === '/index.html';
    
    if (!isHomepage && currentTheme === 'differential-equation') {
      canvas.classList.add('right-positioned');
      canvas3d.classList.add('right-positioned');
    } else {
      canvas.classList.remove('right-positioned');
      canvas3d.classList.remove('right-positioned');
    }
  }
  
  updateCanvasPosition();
  window.addEventListener('theme-change', updateCanvasPosition);
  
  if (document.addEventListener) {
    document.addEventListener('astro:page-load', updateCanvasPosition);
  }

  // Saturn Settings Logic
  const saturnModal = document.getElementById('saturn-settings-modal');
  const closeSaturnBtn = document.getElementById('close-saturn-settings');
  const pCountInput = document.getElementById('saturn-particle-count');
  const speedInput = document.getElementById('saturn-speed');
  const chaosInput = document.getElementById('saturn-chaos');
  
  // Load settings
  const savedSaturnSettings = localStorage.getItem('saturnSettings');
  if (savedSaturnSettings) {
    saturnSettings = JSON.parse(savedSaturnSettings);
    if(pCountInput) pCountInput.value = saturnSettings.particleCount;
    if(speedInput) speedInput.value = saturnSettings.speedMultiplier;
    if(chaosInput) chaosInput.value = saturnSettings.chaosMultiplier;
    updateLabels();
  }

  function updateLabels() {
    if(pCountInput) document.getElementById('saturn-particle-count-val').innerText = pCountInput.value;
    if(speedInput) document.getElementById('saturn-speed-val').innerText = speedInput.value + 'x';
    if(chaosInput) document.getElementById('saturn-chaos-val').innerText = chaosInput.value;
  }

  window.addEventListener('saturn-settings-open', () => {
    saturnModal?.classList.remove('hidden');
    saturnModal?.classList.add('flex');
  });

  closeSaturnBtn?.addEventListener('click', () => {
    saturnModal?.classList.add('hidden');
    saturnModal?.classList.remove('flex');
  });

  pCountInput?.addEventListener('input', (e) => {
    saturnSettings.particleCount = parseInt(e.target.value);
    updateLabels();
    localStorage.setItem('saturnSettings', JSON.stringify(saturnSettings));
    // Re-init to apply particle count change
    if (currentTheme === 'saturn') initSaturn();
  });

  speedInput?.addEventListener('input', (e) => {
    saturnSettings.speedMultiplier = parseFloat(e.target.value);
    updateLabels();
    localStorage.setItem('saturnSettings', JSON.stringify(saturnSettings));
    if (threeMaterial) threeMaterial.uniforms.speedMultiplier.value = saturnSettings.speedMultiplier;
  });

  chaosInput?.addEventListener('input', (e) => {
    saturnSettings.chaosMultiplier = parseFloat(e.target.value);
    updateLabels();
    localStorage.setItem('saturnSettings', JSON.stringify(saturnSettings));
  });

</script>
